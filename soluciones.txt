# 0. Web parameter tampering
    ## FLAG
        1D4855F7337C0C14B6F44946872C4EB33853F40B2D54393FBE94F49F1E19BBB0
    ## HOW
        Descubrimos un formulario oculto en la página de recuperaciónd de contraseñas (http://192.168.1.131/index.php?page=recover). Al inspeccionarlo vemos que se están pre cargando valores en el formulario, los cuales se a través del atributo "hidden". Al cambiar el valor del input del form y enviarlo obtenemos el flag
    ## FIX
        No ocultar valores sensibles que puedan alterar el comportamiento de la aplicación en código de cliente. Este tipo de acciones se deben hacer siempre en backend de tal forma que un usuario no pueda manipularlo.



# 1. SQL INJECTION MEMBERS:
    # FLAG
        10a16d834f9b1e4068b25c4c46fe0284e99e44dceaf08098fc83925ba6310ff5
    # HOW
        En la página de miembros (http://192.168.1.90/?page=member) descubrimos un input el cual sospechamos que puede ser vulnerable a inyecciones SQL al observar la forma que tiene la respuesta de servidor:
            `Unknown column 'pepe' in 'where clause'`

        Probamos varias cosas para destapar una posible vulnerabilidad por inyección SQL y comprobamos que:
        - caracteres especiales se escapan correctamente
        - se borran puntos y comas
        
        Intentamos intuir la forma que puede tener la query que se hace en servidor, analizando el valor que mandamos a servidor y la extructura de la respuesta:
            `SELECT id, name, surname FROM members where id =$id`  (siendo $id el valor que enviamos)

        Probamos a hacer una inyección mediante el operador UNION y tenemos exito. Con él somos capaces de ir indagando poco a poco en el contenido de la base de datos:

        1. Sacamos todas las tablas existentes y su relación de columnas existentes:
            `1 UNION SELECT 1,table_name FROM information_schema.tables`
        2. Sacamos todas las bases de datos con:
            `1 UNION SELECT 1,table_schema FROM information_schema.tables`
        3. Finalmente, somos capaces de extraer información relevante de la tabla de usuarios, la cual da una pista sobre un posible flag
            `1 UNION SELECT Commentaire,countersign FROM Member_Sql_Injection.users`
                - Comentaire: Decrypt this password -> then lower all the char. Sh256 on it and it's good !
                - countersign : 5ff9d0165b4f92b14994e5c685cdce28
        4. Hacemos caso a las instrucciones del comentario:
            - 5ff9d0165b4f92b14994e5c685cdce28, descencriptamos a hash md5 usando la web https://hashes.com/en/decrypt/hash
            - Pasamos FortyTwo a lower case: fortytwo
            - Ejecutamos hash sha256 sobre el token obtenido: "echo -n fortytwo | sha256sum" y obtenemos el flag
    # FIX
        Esta vulnerabilidad es relativamente sencilla de prevenir: no concatenar nunca, directamente, un input de usuario con una query SQL. Si necesitamos hacerlo tenemos alternativas:
        - usar queries parametrizadas, de tal forma que delegamos en el motor de la base de datos la consulta quien tratara el input extrictamente como texto plano. El proceso será algo como:
            1. El motor de la base de datos recibe la query con parámetros como variables, la cual se envía al query planner para inicializar.
            2. Una vez lista la query, se inyectan directamente los valores a consultar, extrictamente como datos
        - si por el motor de base de datos no soportara parámetros para el campo buscado (postgresql no admite parámetros en ids por ejemplo), podríamos delegar la tarea de sanitizar el input en orms o librerías de gestión de base de datos, mucho más versados en la tarea de limpiar inputs de usuario que nosotros (https://node-postgres.com/features/queries#parameterized-query)

# 2. BRUTE FORCE ADMIN:
    ## FLAG
        b3a6e43ddf8b4bbb4125e5e7d23040433827759d4de1c04ea63907479a80a6b2
    ## HOW
        En la vulnerabilidad anterior, al haber explorado la base de datos, vemos una DB que nos llama la atención, `Member_Brute_Force`.
        Probamos a obtener la relación de usuario-contraseña hash con la query en members y obtenemos lo siguiente:
            `1 UNION SELECT username,password FROM Member_Brute_Force.db_default`

               ID: 1 UNION SELECT username,password FROM Member_Brute_Force.db_default 
               First name: root
               Surname : 3bf1114a986ba87ed28fc1b5884fc2f8

               ID: 1 UNION SELECT username,password FROM Member_Brute_Force.db_default 
               First name: admin
               Surname : 3bf1114a986ba87ed28fc1b5884fc2f8
        
        Sospechamos que las contraseñas son un hash md5 y, haciendo un decrypt por fuerza bruta con diccionario usando la web https://hashes.com/en/decrypt/hash obtenemos la contraseña:
        - shadow
        Y con ella, haciendo login con admin en la página de sign in (http://192.168.1.90/index.php?page=signin), obtenemos el flag.

        A posteriori, inspirados por el nombre de la DB y dada la debilidad de la contraseña, nos damos cuenta de que otra forma en la que podíamos obtenido este flag habría sido por fuerza bruta. Así que vamos a enfocar la explicación de esta vulnerabilidad desde este punto de vista.

    ## FIX
        Este flag tiene dos formas de vulnerarse:
            - SQL inyection, explicado en el punto anterior.
            - Contraseña débil
        Para proteger a los usuarios de unas credenciales débiles hay diferentes formas de mejorar:
            - Para empezar, la primera sería obligar a los usuarios a usar contraseñas largas, con variedad de caracteres y proveer además de mecanismos adicionales de autenticación de doble factor.
            - Adicionalmente se podría mejorar la segurar a la hora de almacenar dichas contraseñas ya que ve vemos que el hash utilizado no es más que un simple md5 el cual es bastante fácil de vulnerar por un ataque con diccionario, o fuerza bruta si la contraseña es corta o común. Usar por ejemplo:
                - una estrategia de hash+salt haría más complicada la tarea de reversing del hash
                - un pepper adicional (que es como un salt pero guardado como secreto de la aplicación)
                - algoritmos de hashing más modernos y seguros como bcrypt que ralentizan el tiempo de hasheado haciendo más lenta la encriptación de los mismos.

# 3. Persistent XSS -> posible bug en el reto?
    ## FLAG
        0fbb54bbf7d099713ca4be297e1bc7da0173d8b3c21c1811b916a3a86652724e
    ## HOW
        En la página de comentarios, después de probar varios intentos de inyectar scripts, comprobamos que se sanitizan todos los tags html. Pero si introducimos un nombre de usuario con la letra "a", podemos inyectar javascript (de hecho la validación es tan tonta que si ponemos "a" como nombre de usuario nos da un flag??? Esto parece más bien una bug a la hora de implementar la vulnerabilidad en este CTF):
            - Name: "a"
            - Message: "<script>alert("hacked")</script>"
    ## FIX
        Obviando el posible bug, explicamos la forma de evitar una vulnerabilidad XSS, la cual permite al usuario "colar" código javascript en nuestro servidor con el objetivo de alterar el html que servimos a otros usuarios con fines maliciosos. Hay varias formas de evitar esto:
        - Primeramente y lo más básico sería, sanitizando correctamente los inputs de usuario. Delegando en alguna librería especializada en esto ya que se nos pueden escapar errores.
        - Por otro lado, lo mejor sería separar la lógica de la aplicación del contenido de la parte visual evitando concatenar inputs de usuario con código HTML generado en servidor. Usar frameworks y librerías modernas (como React, Angular, Vue) etc nos permiten evitar inyectar contenido en el DOM ya que estas sanitizan automáticamente las variables, tratando como texto todo aquello que se inserta de forma dinámica en el DOM.

# 4. SQL INJECTION IMAGES:
    ## FLAG
        f2a29020ef3132e01dd61df97fd33ec8d7fcd1388cc9601e7db691d17d4d6188
    ## HOW
        Al listar todas las imágenes de la DB mediante la query desde la página de búsqueda de imágenes, (http://192.168.1.90/index.php?page=searchimg):
            `ID: 1 UNION SELECT title,comment FROM Member_images.list_images`
        observamos lo siguiente:
            - First name: Hack me ?
            - Comment: If you read this just use this md5 decode lowercase then sha256 to win this flag ! : 1928e8083cf461a51303633093573c46
        Hacemos caso y decodificamos mediante md5 `1928e8083cf461a51303633093573c46` obteniendo `albatroz`
        Ahora ejecutamos el algoritmo sha256 de hash sobre `albatroz`: "echo -n albatroz | sha256sum" y obtenemos el flag.
    ## FIX
        Al ser una vulnerabilidad de tipo SQL inyection aplican los mismos fixes que en el flag de SQL INJECTION MEMBERS
    
# 5. ROBOTS.TXT 
    ## FLAG
        d19b4823e0d5600ceed56d5e896ef328d7a2b9e7ac7e80f4fcdb9b10bcb3e7ff
    ## HOW
        Buscamos el clásico fichero robots.txt y observamos que hay varias rutas:
            User-agent: *
            Disallow: /whatever
            Disallow: /.hidden
        Entre ellas nos llama la atención la que se encuentra en /whatever:
            - http://192.168.1.90/whatever/htpasswd
        Dicha ruta contiene un fichero con credenciales: `root:437394baff5aa33daa618be47b75cb49`. Los ficheros `htpasswd` sirven para proteger el acceso a ficheros y rutas restringidas en servidores Apache. 
        Desencriptando con hash md5 437394baff5aa33daa618be47b75cb49 obtenemos `qwerty123@`
        Probamos a entrar en /admin con las credenciales y obtenemos flag
    ## FIX
       Revisar la configuración del servidor para denegar el acceso a estos archivos, evitar colocar archivos sensibles en rutas públicas y, sobre todo, no añadir rutas sensibles en la configuración de robots.

# 6. COOKIE MANIPULATION
    ## FLAG
        df2eb4ba34ed059a1e3e89ff4dfc13445f104a1a52295214def1c4fb1693a5c3
    ## HOW
        Observamos que hay una cookie que nos devuelve el servidor al cargar la página:
            `I_am_admin=68934a3e9455fa72420237eb05902327`
        Probamos a desencriptar el valor de la misma usando un hash md5 68934a3e9455fa72420237eb05902327:false
        Intuimos que puede estar usándose la cookie para identificar al admin, si cambiamos el valor a true y la encriptamos a md5 de nuevo,cambiamos su valor con document.cookie y recargamos, pum obtenemos flag
    ## FIX
        No exponer la autorización de recursos en cliente de forma que un usuario cualquiera pueda manipular sus permisos. Este tipo de acciones siempre se deben llevar a cabo en el servidor, gestionando de forma correcta los roles de los usuarios y sus permisos.
        La forma de arreglarla es que, una vez autenticado el usuario admin, se le devolviera una cookie con un identificador único. Dicha cookie se adjuntaría en cada petición realizada por este usuario con el fin de validar su rol y el acceso a los recursos autorizados en servidor.

# 7. CRAWLER / SCRAPPER
    ## FLAG
        d5eec3ec36cf80dce44a896f961c1831a05526ec215693c8f2c39543497d4466
    ## HOW
        Vemos que en /robots.txt se menciona la ruta /.hidden
        Vemos que dentro .hidden hay muchas subrutas con hashes y que en todas hay un archivo README
        Creamos un script para recorrer recursivamente todas las rutas para ir leyendo todos los README y los volcamos a un archivo
        En uno de los README encontramos el flag:
            `Hey, here is your flag : d5eec3ec36cf80dce44a896f961c1831a05526ec215693c8f2c39543497d4466`
    ## FIX
        Para protegernos del crawling podemos usar diferentes herramientas y estrategias para validar usuarios legítimos:
            - captchas: permiten discernir si quien nos hace una petición es un usuario real o un bot
            - rate limiting: permiten controlar el número de peticiones realizadas por un cliente para evitar bots que escanean rápidamente nuestro site, disuadiendo a los mismos debido a la dificultad de escanear nuestra página con eficiencia temporal.
            - revisar cabeceras user-agent (aunque esto se puede falsear fácilemente) para detectar qué tipo de cliente nos está solicitando un recurso.
            - cloudfare, usar servicios de CDN, firewalls etc que ofrezcan este tipo de protecciones contra crawling, DDos etc.
        NOTA interesante:
            - El objetivo del crawling es simplemente descubrir rutas y urls nuevas con el objetivo de tener un mapa de nuestra web lo más actualizado posible
            - El objetivo del scrapping es el de extraer información del contenido de nuestra web.

# 8. HEADERS MODIFICATION
    ## FLAG
        f2a29020ef3132e01dd61df97fd33ec8d7fcd1388cc9601e7db691d17d4d6188
    ## HOW
        En la página del Albatros inspeccionamos el código html y vemos que hay una serie de comentarios, en concreto dos sospechosos:
            * <!--You must come from : "https://www.nsa.gov/".-->
            * <!-- Let's use this browser : "ft_bornToSec". It will help you a lot.-->
        Tenemos la siguiente idea feliz:
            - cuando dice "You must come from", se refiere a que debemos venir de esa página (header Referer)
            - cuando dice "Let's use this browser", se refiere a que debemos fingir que usamos ese navegador (header User-Agent)
        Desde Firefox, modificamos estos dos headers, hacemos la petición de la página y obtenemos el flag
    ## FIX
        Otra vez, estamos fiándonos de información que se puede manipular desde cliente. Se debería implementar un sistema de autenticación real que valide la identidad del usuario de forma segura, en lugar de depender de headers HTTP que pueden ser falsificados trivialmente para acceder a recursos protegidos.

# 9. FORM - SURVEY
    ## FLAG
        03a944b434d5baff05f46c4bede5792551a2595574bcafc9a6e25f67c382ccaa
    ## HOW
        En la página de las votaciones, vemos que hay un form con un select. Los select disponen opciones de la 1 a la 10. Pero se puede alterar el valor de una de ellas para hacer que nuestro voto valga más.
            - Por ejemplo, hacemos que el valor de una de las opciones sea 100000 y aparece el flag
    ## FIX
        No confiar en el valor recibido en cliente. La lógica de la aplicación debe estar en servidor y es ahí donde debemos comprobar si el valor recibido está dentro del rango apto (1-10) válido para la aplicación.

# 10. CONTENT-TYPE
    ## FLAG
        46910d9ce35b385885a9f7e2b336249d622f29b267a1771fbacf52133beddba8
    ## HOW
        En la página de subir una foto intentamos subir un archivo malicioso, `hacked.sh`
        Vemos que cambiando la extensión del archivo a jpg no surte efecto
        Pero si subimos el archivo malicioso conservando su extensión pero modificando su content-type, obtenemos el flag:
            `curl -s -X POST -F "uploaded=@./hacked.sh;type=image/jpeg" -F "Upload=Upload" http://192.168.1.90/index.php\?page\=upload` 
    ## FIX
        En servidor se está confiando ciegamente en el flag Content-type para verificar los archivos subidos. Al adjuntar este archivo desde el formulario web en el navegador, este infiere automáticamente su Content-type. Pero se puede hacer bypass del mismo escribiendo una query como se muestra en la resolución.
        El arreglo para esta vulnerabilidad sería no confiar en una meta información que nos llega de cliente y verificar dentro del servidor, mediante alguna librería o utilidad, la tipología y confiabilidad del archivo recibido.
    
# 11. PATH TRAVERSAL
    ## FLAG
        b12c4b2cb8094750ae121a676269aa9e2872d07c06e429d25a63196ec1c8c1d0
    ## HOW
        Vemos que la página recibe un url param "page". Tiene toda la pinta de que busca en el file system lo que le pidamos por ese nombre de variable. 
        Probando diferentes rutas, vemos que http://192.168.1.90/index.php?page=../../../../../../../../../etc/passwd funciona
    ## FIX
        Podemos prevenir las vulnerabilidades tipo path traversal mediante la correcta configuración del servidor, por ejemplo:
            - desactivar el listado de directorios
            - servir únicamente desde un directorio público
            - establecer un directorio raíz y no permitir escapar de él.
            
# 12. URL VARIABLE INJECTION
    ## FLAG
        b9e775a0291fed784a2d9680fcfad7edd6b8cdf87648da647aaf4bba288bcab3
    ## HOW
        Los links de redes sociales que aparecen abajo del todo en la web tienen la estructura:
            `http://172.20.10.2/index.php?page=redirect&site=facebook`
        Vemos que el id del site se indica a través de una variable url param. Si inyectamos como site `admin`, obtenemos el flag:
            `http://172.20.10.2/index.php?page=redirect&site=admin`
    ## FIX
        No fiarnos de inputs modificables en cliente para acceder a recursos sensibles
        ??

# 13. REFLECTED XSS
    ## FLAG
        928d819fc19405ae09921a2b71227bd9aba106f9d2d37ac412e9e5a750f1506d
    ## HOW
        Vemos que la imagen de NSA tiene la siguiente url:
            `http://172.20.10.2/?page=media&src=nsa`
        Probamos varias cosas y vemos que el parámetro src es vulnerable a reflected xss: podemos inyectar javascript, codificando a base 64
            - codificamos `<script>alert('hola')</script>`
            - lo inyectamos en la url y obtenemos el flag:
                `http://172.20.10.2/?page=media&src=data:text/html;base64,PHNjcmlwdD5hbGVydCgiaGFja2VkIik8L3NjcmlwdD4=`
    ## FIX
        Este tipo de vulnerabilidad es peligrosa porque, aunque no es persistente, permite al atacante inyectar código malicioso a una url que aparentemente es legítima y compartirla con usuarios.
        Para evitarlo debemos hacer cosas muy parecidas a un XSS persistente:
            - Sanitizar siempre variables de entrada (ya sean inputs o url params) sobre todo si van a acabar reflejadas de alguna forma en el dom
            - Utilizar, al igual que en el caso de xss persistente, librerías y frameworks modernos que sanitizan por nosotros este tipo de inputs
            - Usar políticas CSP adecuadas para evitar que un script malicioso pueda hacer fetch o enviar datos a lugares indeseados.

